<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
          content="Control the volume and manage streaming apps on your Chromecast-enabled devices directly from your browser.">
    <meta name="author" content="@SilviuStroe">
    <meta name="keywords" content="Google Cast, Chromecast, Volume Control, Streaming, Media Control">
    <meta name="google-site-verification" content="wByruZ2Gy-r5VEMOgQZdlt5XtB-3W1Oo1EiV3aFIviI"/>
    <title>Chromecast Volume Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon-16x16.png">
    <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@graph": [
                {
                    "@type": "WebSite",
                    "name": "Chromecast Volume Control",
                    "url": "https://castvolumecontrol.pages.dev",
                    "author": {
                        "@type": "Person",
                        "name": "@SilviuStroe"
                    },
                    "description": "Control the volume and manage streaming apps on your Chromecast-enabled devices directly from your browser."
                },
                {
                    "@type": "WebPage",
                    "name": "Chromecast Volume Control",
                    "description": "Manage the volume of your Chromecast-enabled devices and switch between your favorite streaming apps with ease.",
                    "url": "https://castvolumecontrol.pages.dev"
                },
                {
                    "@type": "SoftwareApplication",
                    "name": "Chromecast Volume Control",
                    "applicationCategory": "Multimedia",
                    "operatingSystem": "Web",
                    "offers": {
                        "@type": "Offer",
                        "price": "0",
                        "priceCurrency": "USD"
                    },
                    "featureList": "Volume control for Chromecast devices, Streaming app management, Easy-to-use interface, No installation required",
                    "description": "A web-based tool to control the volume of Chromecast-enabled devices. Easily manage streaming apps and adjust volume settings directly from your browser."
                }
            ]
        }
    </script>
</head>
<body class="font-sans bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 m-0 flex flex-col justify-center items-center p-2 md:p-4 lg:p-6 min-h-screen">
<div class="control-panel bg-white dark:bg-gray-800 p-4 md:p-6 lg:p-10 rounded-lg shadow-md w-full md:w-4/5 max-w-xl mx-auto overflow-auto">
    <h1 class="text-xl md:text-3xl font-bold text-gray-800 dark:text-gray-100 mb-6">Chromecast Volume Control</h1>
    <p class="text-base text-gray-600 dark:text-gray-300 mb-6 leading-relaxed">
        Manage the volume of your Chromecast-enabled devices and switch between your favorite streaming apps with ease.
    </p>
    <div class="app-select-container mb-6">
        <label for="appSelect" class="block mb-2 font-bold dark:text-gray-100">Choose the app playing on your
            device:</label>
        <select id="appSelect" required
                class="w-full p-2 rounded border border-gray-300 dark:border-gray-600 mt-1 bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
            <option value="">Select an app</option>
            <option value="CC32E753">Spotify</option>
            <option value="2DB7CC49">YouTube Music</option>
            <option value="B143C57E">SoundCloud</option>
            <option value="CA5E8412">Netflix</option>
            <option value="9AC194DC">Plex</option>
            <option value="233637DE">YouTube</option>
            <option value="C3DE6BC2">Disney+</option>
            <option value="10AAD887">All 4</option>
            <option value="B88B034A">Dailymotion</option>
            <option value="B3DCF968">Twitch</option>
            <option value="2BA92214">BBC iPlayer</option>
            <option value="5E645BCC">BubbleUPnP</option>
            <option value="12F05308">TuneIn Free</option>
            <option value="211CD751">Pandora</option>
            <option value="0F5096E8">Chrome Mirroring</option>
            <option value="85CDB22F">Chrome Audio Mirroring</option>
            <option value="CC1AD845">Default Media Receiver</option>
        </select>
    </div>
    <div class="flex justify-between items-center mb-6">
        <button id="castButton"
                class="bg-blue-600 dark:bg-blue-700 text-white py-2 px-4 rounded cursor-pointer text-lg transition-colors duration-300 w-1/2 mr-2 hover:bg-blue-700 dark:hover:bg-blue-800">
            Connect to Device
        </button>
        <button id="stopButton" style="display: none"
                class="bg-red-600 dark:bg-red-700 text-white py-2 px-4 rounded cursor-pointer text-lg transition-colors duration-300 w-1/2 ml-2 hover:bg-red-700 dark:hover:bg-red-800">
            Stop Media
        </button>
    </div>
    <div class="volume-container mb-6">
        <label for="volumeControl" class="block text-lg text-gray-600 dark:text-gray-300 mb-2">Volume:</label>
        <div class="slider-container flex items-center">
            <button id="muteButton" disabled class="bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-3 rounded mr-2 hover:bg-gray-400 dark:hover:bg-gray-500 transition-colors duration-300">üîä</button>
            <input type="range" id="volumeControl" min="0" max="100" step="1" disabled class="flex-grow mr-2 accent-blue-600">
            <span id="volumeValue" class="volume-value text-lg text-gray-800 dark:text-gray-200 min-w-[3ch]">0</span>
        </div>
    </div>
    <div id="connectionStatus" class="mb-4 p-3 rounded-lg text-center hidden">
        <span id="statusText" class="font-medium"></span>
    </div>
    <div class="media-info">
        <h3 id="mediaTitle" class="text-lg font-bold text-gray-700 dark:text-white mb-2"></h3>
        <img id="mediaImage" src="#" alt="Media Thumbnail" class="hidden rounded-lg w-full md:w-48 h-auto object-cover">
    </div>
</div>
<div class="use-cases bg-gray-200 dark:bg-gray-800 p-5 mt-8 rounded-lg shadow-md w-full md:w-4/5 max-w-xl mx-auto">
    <h2 class="text-2xl font-semibold text-gray-700 dark:text-gray-100">How Chromecast Volume Control Enhances Your
        Experience</h2>
    <p>Discover how users from various backgrounds use our app to streamline their media experience:</p>
    <ul class="list-disc ml-5">
        <li class="dark:text-gray-300"><strong>For Work and Play:</strong> Seamlessly adjust the volume during
            work-from-home sessions or while enjoying a movie night, all from your browser.
        </li>
        <li class="dark:text-gray-300"><strong>Music Lovers:</strong> Effortlessly control the volume of your favorite
            Spotify playlists or YouTube Music tracks on your Chromecast-enabled devices.
        </li>
        <li class="dark:text-gray-300"><strong>Party Hosts:</strong> Keep the party going by controlling the music
            volume on your Chromecast-enabled TV or speakers without missing a beat.
        </li>
        <li class="dark:text-gray-300"><strong>Desktop Users:</strong> Desktop users can effortlessly control their
            Google Nest or other Chromecast-enabled devices directly from their browser.
        </li>
        <li class="dark:text-gray-300"><strong>Accessibility:</strong> Those with mobility challenges can easily adjust
            device settings without needing to physically access them.
        </li>
        <li class="dark:text-gray-300"><strong>Privacy First:</strong> This app operates without any backend servers and
            requires no installations, ensuring your data stays with you.
        </li>
    </ul>
</div>
<footer class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 my-2">
    <div class="container mx-auto px-4 py-5 text-center">
        <p class="mb-4">&copy; 2023 Chromecast Volume Control. All Rights Reserved.</p>
        <div class="flex justify-center space-x-4">
            <a rel="noopener noreferrer" class="github-button" href="https://github.com/BrainicHQ/CastVolumeControl"
               data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"
               aria-label="Star BrainicHQ/CastVolumeControl on GitHub">Star on GitHub</a>
            <a href="https://www.buymeacoffee.com/silviu" target="_blank" rel="noopener noreferrer"
               aria-label="Support me on Buy Me a Coffee" class="text-blue-500 dark:text-blue-400 hover:underline">‚òïÔ∏è
                Support this project</a>
            <a class="github-button" href="https://github.com/BrainicHQ/CastVolumeControl/issues"
               data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-issue-opened"
               data-show-count="true" aria-label="Issue BrainicHQ/CastVolumeControl on GitHub">Report Issue üêõ</a>
        </div>
    </div>
</footer>

<script async defer src="https://buttons.github.io/buttons.js"></script>
<script>
    class CastVolumeController {
        constructor() {
            this.castContext = null;
            this.currentSession = null;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 5;
            this.reconnectDelay = 2000;
            this.heartbeatInterval = null;
            this.volumeSyncInterval = null;
            this.isConnecting = false;
            this.connectionState = 'disconnected';
            
            this.elements = {
                appSelect: null,
                castButton: null,
                stopButton: null,
                volumeControl: null,
                volumeValue: null,
                muteButton: null,
                connectionStatus: null,
                statusText: null,
                mediaTitle: null,
                mediaImage: null
            };
            
            this.lastVolume = 50;
            this.isMuted = false;
            
            this.init();
        }
        
        init() {
            this.initializeElements();
            this.loadCastFramework();
            this.setupEventListeners();
            this.restoreState();
        }
        
        initializeElements() {
            this.elements.appSelect = document.getElementById('appSelect');
            this.elements.castButton = document.getElementById('castButton');
            this.elements.stopButton = document.getElementById('stopButton');
            this.elements.volumeControl = document.getElementById('volumeControl');
            this.elements.volumeValue = document.getElementById('volumeValue');
            this.elements.muteButton = document.getElementById('muteButton');
            this.elements.connectionStatus = document.getElementById('connectionStatus');
            this.elements.statusText = document.getElementById('statusText');
            this.elements.mediaTitle = document.getElementById('mediaTitle');
            this.elements.mediaImage = document.getElementById('mediaImage');
        }
        
        loadCastFramework() {
            if (window.chrome && !window.chrome.cast) {
                const script = document.createElement('script');
                script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
                script.onload = () => {
                    window['__onGCastApiAvailable'] = (isAvailable) => {
                        if (isAvailable) {
                            this.initializeCastApi();
                        } else {
                            this.handleCastUnavailable();
                        }
                    };
                };
                script.onerror = () => this.handleCastUnavailable();
                document.head.appendChild(script);
            } else if (window.chrome && window.chrome.cast) {
                this.initializeCastApi();
            } else {
                this.handleCastUnavailable();
            }
        }
        
        handleCastUnavailable() {
            console.error('Google Cast SDK not available');
            this.showNotification('Chromecast is not supported in this browser', 'error');
            this.elements.castButton.disabled = true;
            this.elements.volumeControl.disabled = true;
        }
        
        async initializeCastApi() {
            try {
                this.castContext = cast.framework.CastContext.getInstance();
                
                const savedAppId = localStorage.getItem('selectedAppId');
                if (savedAppId) {
                    this.elements.appSelect.value = savedAppId;
                }
                
                this.castContext.setOptions({
                    receiverApplicationId: savedAppId || chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
                    resumeSavedSession: true
                });
                
                this.castContext.addEventListener(
                    cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
                    (event) => this.handleSessionStateChanged(event)
                );
                
                this.castContext.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    (event) => this.handleCastStateChanged(event)
                );
                
                // Wait a moment for the Cast SDK to fully initialize
                await this.delay(500);
                
                // Check for existing session and resume without interrupting playback
                const existingSession = this.castContext.getCurrentSession();
                if (existingSession) {
                    console.log('Existing session found, resuming without interruption...');
                    this.attachToSession(existingSession);
                    this.updateConnectionState('connected');
                    this.elements.castButton.textContent = 'Disconnect';
                    this.elements.stopButton.style.display = 'block';
                } else {
                    console.log('No existing session found');
                }
                
                this.startHeartbeat();
                console.log('Cast API initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize Cast API:', error);
                this.showNotification('Failed to initialize Chromecast', 'error');
            }
        }
        
        setupEventListeners() {
            this.elements.castButton.addEventListener('click', () => this.handleCastButtonClick());
            this.elements.stopButton.addEventListener('click', () => this.stopMedia());
            this.elements.volumeControl.addEventListener('input', (event) => this.handleVolumeChange(event));
            this.elements.muteButton.addEventListener('click', () => this.toggleMute());
            
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    this.refreshSession();
                }
            });
            
            window.addEventListener('online', () => this.handleNetworkOnline());
            window.addEventListener('offline', () => this.handleNetworkOffline());
        }
        
        restoreState() {
            const savedVolume = localStorage.getItem('lastVolume');
            if (savedVolume) {
                this.elements.volumeControl.value = savedVolume;
                this.elements.volumeValue.textContent = savedVolume;
            }
        }
        
        async handleCastButtonClick() {
            if (this.isConnecting) {
                this.showNotification('Connection in progress...', 'info');
                return;
            }
            
            const buttonText = this.elements.castButton.textContent.trim();
            
            if (buttonText === 'Connect to Device') {
                await this.connectToDevice();
            } else if (buttonText === 'Disconnect') {
                this.disconnectFromDevice();
            }
        }
        
        async connectToDevice() {
            const selectedAppId = this.elements.appSelect.value;
            if (!selectedAppId) {
                this.showNotification('Please select an app first', 'warning');
                this.elements.appSelect.focus();
                return;
            }
            
            this.isConnecting = true;
            this.updateConnectionState('connecting');
            this.elements.castButton.textContent = 'Connecting...';
            this.elements.castButton.disabled = true;
            
            try {
                localStorage.setItem('selectedAppId', selectedAppId);
                
                this.castContext.setOptions({
                    receiverApplicationId: selectedAppId,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
                    resumeSavedSession: true
                });
                
                await this.castContext.requestSession();
                console.log('Cast session started successfully');
                this.reconnectAttempts = 0;
                
            } catch (error) {
                console.error('Error starting Cast session:', error);
                this.handleConnectionError(error);
            } finally {
                this.isConnecting = false;
                this.elements.castButton.disabled = false;
            }
        }
        
        disconnectFromDevice() {
            if (this.castContext && this.currentSession) {
                // Only disconnect if explicitly requested by user, not on page refresh
                this.castContext.endCurrentSession(false);
                this.updateConnectionState('disconnected');
                console.log('Explicitly disconnected from session');
            }
        }
        
        handleSessionStateChanged(event) {
            const stopButton = this.elements.stopButton;
            
            switch (event.sessionState) {
                case cast.framework.SessionState.SESSION_STARTED:
                    console.log('New session started');
                    this.currentSession = this.castContext.getCurrentSession();
                    if (this.currentSession) {
                        this.attachToSession(this.currentSession);
                        this.updateConnectionState('connected');
                        this.elements.castButton.textContent = 'Disconnect';
                        stopButton.style.display = 'block';
                        this.startVolumeSync();
                        this.showNotification('Connected to Chromecast device', 'success');
                        this.reconnectAttempts = 0; // Reset reconnect attempts on successful connection
                    }
                    break;
                    
                case cast.framework.SessionState.SESSION_RESUMED:
                    console.log('Session resumed - maintaining playback');
                    this.currentSession = this.castContext.getCurrentSession();
                    if (this.currentSession) {
                        this.attachToSession(this.currentSession);
                        this.updateConnectionState('connected');
                        this.elements.castButton.textContent = 'Disconnect';
                        stopButton.style.display = 'block';
                        this.startVolumeSync();
                        // Don't show notification for resumed sessions to avoid spam
                        console.log('Session successfully resumed without interrupting playback');
                        this.reconnectAttempts = 0;
                    }
                    break;
                    
                case cast.framework.SessionState.SESSION_ENDED:
                    console.log('Session ended by user or device');
                    this.currentSession = null;
                    this.updateConnectionState('disconnected');
                    this.elements.castButton.textContent = 'Connect to Device';
                    this.elements.volumeControl.disabled = true;
                    stopButton.style.display = 'none';
                    this.clearMediaInfo();
                    this.stopVolumeSync();
                    break;
                    
                case cast.framework.SessionState.NO_SESSION:
                    console.log('No active session available');
                    // Only update UI if we actually lost a session
                    if (this.currentSession) {
                        this.currentSession = null;
                        this.updateConnectionState('disconnected');
                        this.elements.castButton.textContent = 'Connect to Device';
                        this.elements.volumeControl.disabled = true;
                        stopButton.style.display = 'none';
                        this.clearMediaInfo();
                        this.stopVolumeSync();
                    }
                    break;
            }
        }
        
        handleCastStateChanged(event) {
            console.log('Cast state changed:', event.castState);
            
            switch (event.castState) {
                case cast.framework.CastState.NO_DEVICES_AVAILABLE:
                    this.showNotification('No Chromecast devices found', 'warning');
                    break;
                case cast.framework.CastState.NOT_CONNECTED:
                    if (this.connectionState === 'connected') {
                        this.attemptReconnection();
                    }
                    break;
            }
        }
        
        attachToSession(session) {
            this.currentSession = session;
            console.log('Attaching to session:', session);
            
            try {
                // Add session update listener for volume changes
                if (typeof session.addUpdateListener === 'function') {
                    session.addUpdateListener(() => {
                        this.syncVolumeState();
                    });
                }
                
                // Check for media session and add listeners
                this.setupMediaListeners(session);
                
                // Initial state sync
                this.updateMediaInformation();
                this.syncVolumeState();
                this.elements.volumeControl.disabled = false;
                
            } catch (error) {
                console.error('Error attaching to session:', error);
                this.showNotification('Session attachment failed', 'error');
            }
        }
        
        setupMediaListeners(session) {
            try {
                // Try to get current media session
                const mediaSession = session.getMediaSession ? session.getMediaSession() : null;
                if (mediaSession && typeof mediaSession.addUpdateListener === 'function') {
                    mediaSession.addUpdateListener(() => {
                        this.updateMediaInformation();
                    });
                }
                
                // Listen for new media sessions
                if (typeof session.addMediaListener === 'function') {
                    session.addMediaListener((event) => {
                        console.log('Media session event:', event);
                        const newMediaSession = session.getMediaSession();
                        if (newMediaSession && typeof newMediaSession.addUpdateListener === 'function') {
                            newMediaSession.addUpdateListener(() => {
                                this.updateMediaInformation();
                            });
                        }
                        this.updateMediaInformation();
                    });
                }
            } catch (error) {
                console.error('Error setting up media listeners:', error);
            }
        }
        
        updateMediaInformation() {
            if (!this.currentSession) return;
            
            const mediaSession = this.currentSession.getMediaSession();
            
            if (mediaSession && mediaSession.media && mediaSession.media.metadata) {
                const metadata = mediaSession.media.metadata;
                this.elements.mediaTitle.textContent = metadata.title || 'Unknown Title';
                
                if (metadata.images && metadata.images.length > 0) {
                    this.elements.mediaImage.src = metadata.images[0].url;
                    this.elements.mediaImage.classList.remove('hidden');
                } else {
                    this.elements.mediaImage.classList.add('hidden');
                }
            } else {
                this.clearMediaInfo();
            }
        }
        
        clearMediaInfo() {
            this.elements.mediaTitle.textContent = 'No media information';
            this.elements.mediaImage.classList.add('hidden');
        }
        
        syncVolumeState() {
            if (!this.currentSession) return;
            
            try {
                const currentVolume = Math.round(this.currentSession.getVolume() * 100);
                const isMuted = this.currentSession.isMuted ? this.currentSession.isMuted() : currentVolume === 0;
                
                // Update volume slider and display
                this.elements.volumeControl.value = currentVolume;
                this.elements.volumeValue.textContent = currentVolume;
                
                // Update mute button state
                if (isMuted && currentVolume === 0) {
                    this.isMuted = true;
                    this.elements.muteButton.textContent = 'üîá';
                    this.elements.muteButton.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                    this.elements.muteButton.classList.add('bg-red-500', 'text-white');
                } else {
                    this.isMuted = false;
                    this.elements.muteButton.textContent = 'üîä';
                    this.elements.muteButton.classList.remove('bg-red-500', 'text-white');
                    this.elements.muteButton.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                }
                
                // Save volume state
                if (currentVolume > 0) {
                    localStorage.setItem('lastVolume', currentVolume.toString());
                    this.lastVolume = currentVolume;
                }
                
            } catch (error) {
                console.error('Error syncing volume state:', error);
            }
        }
        
        handleVolumeChange(event) {
            const volumeLevel = parseInt(event.target.value);
            this.adjustVolume(volumeLevel);
            this.elements.volumeValue.textContent = volumeLevel;
            localStorage.setItem('lastVolume', volumeLevel.toString());
            
            // Update mute state if volume changed
            if (volumeLevel > 0 && this.isMuted) {
                this.isMuted = false;
                this.elements.muteButton.textContent = 'üîä';
                this.elements.muteButton.classList.remove('bg-red-500', 'text-white');
                this.elements.muteButton.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
            }
        }
        
        async adjustVolume(volumeLevel) {
            if (!this.currentSession) {
                console.log('No active Cast session');
                return;
            }
            
            try {
                const normalizedVolume = volumeLevel / 100;
                await this.currentSession.setVolume(normalizedVolume);
                console.log('Volume set to', normalizedVolume);
            } catch (error) {
                console.error('Error setting volume:', error);
                this.showNotification('Failed to adjust volume', 'error');
                
                if (error.code === 'session_error') {
                    this.attemptReconnection();
                }
            }
        }
        
        stopMedia() {
            if (!this.currentSession) {
                console.log('No active Cast session');
                return;
            }
            
            try {
                this.currentSession.endSession(true);
                this.elements.stopButton.style.display = 'none';
                console.log('Media stopped');
                this.showNotification('Media stopped', 'info');
            } catch (error) {
                console.error('Error stopping media:', error);
                this.showNotification('Failed to stop media', 'error');
            }
        }
        
        toggleMute() {
            if (!this.currentSession) return;
            
            try {
                if (this.isMuted) {
                    this.adjustVolume(this.lastVolume);
                    this.isMuted = false;
                    this.elements.muteButton.textContent = 'üîä';
                    this.elements.muteButton.classList.remove('bg-red-500', 'text-white');
                    this.elements.muteButton.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                } else {
                    this.lastVolume = parseInt(this.elements.volumeControl.value);
                    this.adjustVolume(0);
                    this.isMuted = true;
                    this.elements.muteButton.textContent = 'üîá';
                    this.elements.muteButton.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                    this.elements.muteButton.classList.add('bg-red-500', 'text-white');
                }
            } catch (error) {
                console.error('Error toggling mute:', error);
                this.showNotification('Failed to toggle mute', 'error');
            }
        }
        
        startHeartbeat() {
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
            }
            
            this.heartbeatInterval = setInterval(() => {
                this.checkConnectionHealth();
            }, 10000);
        }
        
        checkConnectionHealth() {
            if (this.currentSession) {
                try {
                    const volume = this.currentSession.getVolume();
                    if (volume === undefined || volume === null) {
                        console.warn('Session appears unhealthy, attempting reconnection');
                        this.attemptReconnection();
                    }
                } catch (error) {
                    console.warn('Session health check failed:', error);
                    this.attemptReconnection();
                }
            }
        }
        
        startVolumeSync() {
            if (this.volumeSyncInterval) {
                clearInterval(this.volumeSyncInterval);
            }
            
            this.volumeSyncInterval = setInterval(() => {
                this.syncVolumeState();
            }, 5000);
        }
        
        stopVolumeSync() {
            if (this.volumeSyncInterval) {
                clearInterval(this.volumeSyncInterval);
                this.volumeSyncInterval = null;
            }
        }
        
        async attemptReconnection() {
            if (this.reconnectAttempts >= this.maxReconnectAttempts || this.isConnecting) {
                return;
            }
            
            this.reconnectAttempts++;
            console.log(`Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            
            this.showNotification(`Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'info');
            
            await this.delay(this.reconnectDelay * this.reconnectAttempts);
            
            try {
                await this.connectToDevice();
            } catch (error) {
                console.error('Reconnection attempt failed:', error);
                
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    this.showNotification('Failed to reconnect. Please try manually.', 'error');
                    this.updateConnectionState('failed');
                }
            }
        }
        
        async refreshSession() {
            if (this.castContext) {
                try {
                    const session = this.castContext.getCurrentSession();
                    if (session) {
                        if (session !== this.currentSession) {
                            console.log('Refreshing session after visibility change');
                            this.attachToSession(session);
                            this.updateConnectionState('connected');
                        } else {
                            // Session is the same, just sync state
                            this.syncVolumeState();
                            this.updateMediaInformation();
                        }
                    } else if (this.currentSession) {
                        // Lost session, try to reconnect
                        console.log('Session lost during page switch, attempting reconnection');
                        this.attemptReconnection();
                    }
                } catch (error) {
                    console.error('Error refreshing session:', error);
                }
            }
        }
        
        handleNetworkOnline() {
            console.log('Network connection restored');
            this.showNotification('Network restored', 'success');
            
            setTimeout(() => {
                if (this.connectionState === 'connected' && !this.currentSession) {
                    this.attemptReconnection();
                }
            }, 2000);
        }
        
        handleNetworkOffline() {
            console.log('Network connection lost');
            this.showNotification('Network connection lost', 'warning');
        }
        
        handleConnectionError(error) {
            console.error('Connection error:', error);
            
            let message = 'Connection failed';
            if (error.code === 'cancel') {
                message = 'Connection cancelled';
            } else if (error.code === 'timeout') {
                message = 'Connection timed out';
            } else if (error.code === 'receiver_unavailable') {
                message = 'Device unavailable';
            }
            
            this.showNotification(message, 'error');
            this.updateConnectionState('failed');
            this.elements.castButton.textContent = 'Connect to Device';
        }
        
        updateConnectionState(state) {
            this.connectionState = state;
            
            const statusMessages = {
                'connecting': 'Connecting to device...',
                'connected': 'Connected successfully',
                'disconnected': 'Not connected',
                'failed': 'Connection failed'
            };
            
            const statusStyles = {
                'connecting': 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200',
                'connected': 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200',
                'disconnected': 'bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200',
                'failed': 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
            };
            
            this.elements.statusText.textContent = statusMessages[state] || 'Unknown status';
            this.elements.connectionStatus.className = `mb-4 p-3 rounded-lg text-center ${statusStyles[state]}`;
            this.elements.connectionStatus.classList.remove('hidden');
            
            switch (state) {
                case 'connecting':
                    this.elements.castButton.classList.add('opacity-50');
                    this.elements.volumeControl.disabled = true;
                    this.elements.muteButton.disabled = true;
                    break;
                case 'connected':
                    this.elements.castButton.classList.remove('opacity-50');
                    this.elements.volumeControl.disabled = false;
                    this.elements.muteButton.disabled = false;
                    setTimeout(() => {
                        this.elements.connectionStatus.classList.add('hidden');
                    }, 3000);
                    break;
                case 'disconnected':
                case 'failed':
                    this.elements.castButton.classList.remove('opacity-50');
                    this.elements.volumeControl.disabled = true;
                    this.elements.muteButton.disabled = true;
                    break;
            }
        }
        
        showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 ${this.getNotificationStyles(type)}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('opacity-0', 'translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        getNotificationStyles(type) {
            const styles = {
                success: 'bg-green-500 text-white',
                error: 'bg-red-500 text-white',
                warning: 'bg-yellow-500 text-black',
                info: 'bg-blue-500 text-white'
            };
            return styles[type] || styles.info;
        }
        
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        destroy() {
            // Clean up intervals
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
            }
            if (this.volumeSyncInterval) {
                clearInterval(this.volumeSyncInterval);
            }
            
            // DO NOT disconnect session on page unload - let it continue playing
            // Only clean up local references
            console.log('Cleaning up controller, keeping session alive');
        }
    }
    
    let castController;
    
    document.addEventListener('DOMContentLoaded', () => {
        castController = new CastVolumeController();
    });
    
    // Clean up on page unload but DON'T disconnect the cast session
    window.addEventListener('beforeunload', () => {
        if (castController) {
            castController.destroy();
        }
    });
    
    // Handle page visibility changes to restore sessions
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && castController) {
            // Page became visible again, refresh session
            setTimeout(() => {
                castController.refreshSession();
            }, 100);
        }
    });
</script>
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function () {
            navigator.serviceWorker.register('/service-worker.js').then(function (registration) {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, function (err) {
                console.log('ServiceWorker registration failed: ', err);
            });
        });
    }
</script>
</body>
</html>
